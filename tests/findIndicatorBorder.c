#pragma config(Sensor, S1,     line_follower_left, sensorEV3_Color)
#pragma config(Sensor, S2,     line_follower_right, sensorEV3_Color)
#pragma config(Sensor, S3,     HT_color_l,               sensorI2CCustom)
#pragma config(Sensor, S4,     HT_color_r,               sensorI2CCustom)
#pragma config(Motor,  motorA,          motor_grab,    tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          motor_drive_left, tmotorEV3_Medium, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          motor_drive_right, tmotorEV3_Medium, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          motor_dropper, tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "../lib/minmaxclip.h"
#include "../lib/colorV2jester.h"
#include "../lib/driveModule.h"

#pragma debuggerWindows("debugStream");

#define color_left S3
#define color_right S4

/** 
 * Robot position: ~5cm from line going to indicators
 * 
 * 
 * 
*/



// FLAGS for ITC
bool enableMeasure = true;
bool reset = false;

// solveSide side effect
int side = 0;
// measureLB side effect
int measureIndex = 0;

float avgWl, avgWr;
int iter = 0;

//_measureIndicators
task measureIndicators()
{
	enableMeasure = true;
	rgbw curr;
	rgbw max;
	max.r = 0;
	max.g = 0;
	max.b = 0;
	max.w = 0;

	while(enableMeasure)
	{
		getRGBW(color_right, curr);
		rgbwMaxComponent(max, curr);
	}
    avgWr = (avgWr * iter + max.w) / iter + 1;
    writeDebugStreamLine("IND R: SUM: %d  W: %d", (max.r + max.g + max.b), max.w);
}
//_measureIndicators_l
task measureIndicators_l()
{
	enableMeasure  = true;
	rgbw curr;
	rgbw max;
	max.r = 0;
	max.g = 0;
	max.b = 0;
	max.w = 0;

	while(enableMeasure)
	{
		getRGBW(color_left, curr);
		rgbwMaxComponent(max, curr);
	}
    avgWl = (avgWl * iter + max.w) / iter + 1;
	writeDebugStreamLine("IND L: SUM: %d  W: %d", (max.r + max.g + max.b), max.w);
}


// _resetStart
task resetStart()
{
	setMotorSpeed(motor_dropper, 10);
	setMotorSpeed(motor_grab, -25);
	wait1Msec(2000);
	setMotorSpeed(motor_dropper, 0);
	setMotorSpeed(motor_grab, 0);
	resetMotorEncoder(motor_dropper);
	wait1Msec(200);
	setMotorTarget(motor_dropper, -10, 10);
	waitUntilMotorStop(motor_dropper);
	resetMotorEncoder(motor_grab);
	resetMotorEncoder(motor_dropper);
	playTone(440, 10);
	reset = true;
}

// _main
task main()
{
	clearDebugStream();
	setMotorBrakeMode(motorA, motorBrake);
	setMotorBrakeMode(motorB, motorBrake);
	setMotorBrakeMode(motorC, motorBrake);
	setMotorBrakeMode(motorD, motorBrake);
	if (!verifySetupHTCOL(S3) || !verifySetupHTCOL(S4)) {
		writeDebugStreamLine("[INIT] SENSOR ERROR, check ht colors");
	}
	startTask(resetStart);
	eraseDisplay();
	waitUntil(reset);
	setLEDColor(ledGreen);
	waitForButtonPress();
	eraseDisplay();
	setLEDColor(ledOff);
	delay(150);
	clearTimer(T4);

    writeDebugStreamLine("[ INFO ] Indicator Border Val finder v0.0.1 by jesster");
    
    for (int i = 0; i < 10; i++)
    {
        enableMeasure = true;

        startTask(measureIndicators);
	    startTask(measureIndicators_l);
        lfPDline(15, true, true);
        resetMotorEncoder(motor_drive_right);

        lfPDcm(15, side == 0 ? 5.5: 5.5);

        enableMeasure = false;
        brake(15, 7.5);
        resetMotorEncoder(motor_drive_right);
        driveCm(-15, -15, 12.5);
        brake(-15, 13.5);
        writeDebugStreamLine("L: %f ; R: %f", avgWl, avgWr);
    }

    brake(0, 0);
	eraseDisplay();
	displayCenteredBigTextLine(4, "%d.0 s", (float)time100[T4]/10.0);
	writeDebugStreamLine("TIME: %d", (float)time100[T4]/10.0);
	delay(10000);
	stopAllTasks();
}
