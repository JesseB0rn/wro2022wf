#pragma config(Sensor, S2,     line_follower_right, sensorEV3_Color)
#pragma config(Sensor, S1,     line_follower_left, sensorEV3_Color)
#pragma config(Sensor, S4,     color_right,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S3,     color_left,     sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Motor,  motorD,          motor_dropper, tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          motor_drive_left, tmotorEV3_Medium, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorC,          motor_drive_right, tmotorEV3_Medium, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorA,          motor_grab,    tmotorEV3_Medium, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

float LF_P_a = 0.000055;
float LF_P_u = 45;
float LF_P_v = 0.08;
float LF_D_a = 0.0018;
float LF_D_u = 35;
float LF_D_v = 6;

int measureIndex = 0;
float tireDiameter = 6.24;
float tireDistance = 17.20;
float brakeCons = 0.08;
float brakeConsTurn = 0.11;
bool colors[4];
int side = 0;
bool loop_stop = false;
bool reset = false;


int borderRGB = 22;

//_lfPDcm
void lfPDcm(float speed, float distance)
{
	float kP = 0;
	float kD = 0;
	float error = 0;
	float lastError = 0;
	float derivative = 0;
	float correction = 0;
	float sum = 0;
	float value_left = 0;
	float value_right = 0;
	float time = 0;
	if(speed == 15)
	{
		kP = 0.1;
		kD = 1.5;
		} else {
		kP = LF_P_a*pow(speed - LF_P_u, 2) + LF_P_v;
		kD = LF_D_a*pow(speed - LF_D_u, 2) + LF_D_v;
	}
	while(distance >= getMotorEncoder(motor_drive_right)/360*PI*tireDiameter)
	{
		value_left = getColorReflected(line_follower_left);
		value_right = getColorReflected(line_follower_right);
		error = value_left - value_right;
		sum = value_left + value_right;
		time = time1[timer1];
		clearTimer(timer1);
		derivative = error - lastError;
		correction = error*kP + derivative*kD/time;
		if(sum <= 55)
		{
			setMotorSpeed(motorB, speed);
			setMotorSpeed(motorC, speed);
			} else {
			setMotorSpeed(motorB, speed + correction);
			setMotorSpeed(motorC, speed - correction);
		}
		lastError = error;
		waitUntil(time1[timer1] >= 5);
	}
}


//_lfPDline
void lfPDline(float speed, bool sensor1, bool sensor4)
{
	float kP = 0;
	float kD = 0;
	float error = 0;
	float lastError = 0;
	float derivative = 0;
	float correction = 0;
	float sum = 0;
	float value_left = 0;
	float value_right = 0;
	float time = 0;
	loop_stop = false;
	if(speed == 15)
	{
		kP = 0.1;
		kD = 1.5;
		} else {
		kP = LF_P_a*pow(speed - LF_P_u, 2) + LF_P_v;
		kD = LF_D_a*pow(speed - LF_D_u, 2) + LF_D_v;
	}
	while(loop_stop == false)
	{
		value_left = getColorReflected(line_follower_left);
		value_right = getColorReflected(line_follower_right);
		error = value_left - value_right;
		sum = value_left + value_right;
		time = time1[timer1];
		clearTimer(timer1);
		derivative = error  - lastError;
		correction = error*kP + derivative*kD/time;
		if(sum <= 55)
		{
			setMotorSpeed(motorB, speed);
			setMotorSpeed(motorC, speed);
			} else {
			setMotorSpeed(motorB, speed + correction);
			setMotorSpeed(motorC, speed - correction);
		}
		lastError = error;
		if(sensor1 == true && sensor4 == true)
		{
			loop_stop = (sum <= 40);
			} else {
			if(sensor1 == true)
			{
				loop_stop = value_right <= 15;
				} else {
				loop_stop = value_left <= 15;
			}
		}
		waitUntil(time1[timer1] >= 5);
	}
}


//_lfPDacc
void lfPDacc(float speedStart, float speedEnd)
{
	float kP = 0;
	float kD = 0;
	float error = 0;
	float lastError = 0;
	float derivative = 0;
	float correction = 0;
	float sum = 0;
	float value_left = 0;
	float value_right = 0;
	float time = 0;
	float accConstant = 0;
	float currentSpeed = 0;
	float counter = 0;
	if(speedStart < speedEnd)
	{
		accConstant = 1;
		} else {
		accConstant = -1;
	}
	while(speedStart+accConstant*counter != speedEnd)
	{
		currentSpeed = speedStart+accConstant*counter;
		if(currentSpeed < 6)
		{
			currentSpeed = 6;
		}
		kP = (LF_P_a*pow(currentSpeed - LF_P_u, 2) + LF_P_v);
		kD = (LF_D_a*pow(currentSpeed - LF_D_u, 2) + LF_D_v);
		//kP = pow(currentSpeed, 0.5)*0.024;
		//kD = pow(currentSpeed, 0.5)*0.25;
		value_left = getColorReflected(line_follower_left);
		value_right = getColorReflected(line_follower_right);
		error = value_left - value_right;
		sum = value_left + value_right;
		time = time1[timer1];
		clearTimer(timer1);
		derivative = error - lastError;
		correction = error*kP + derivative*kD/time;
		if(sum <= 55)
		{
			setMotorSpeed(motorB, currentSpeed);
			setMotorSpeed(motorC, currentSpeed);
			} else {
			setMotorSpeed(motorB, currentSpeed + correction);
			setMotorSpeed(motorC, currentSpeed - correction);
		}
		lastError = error;
		waitUntil(time1[timer1] >= 5);
		counter ++;
	}
}


//_lfPDstart
void lfPDstart(float speed, float distance)
{
	float kP = 0.15;
	float kD = 10;
	if(speed == 60)
	{
		kP = 0.15;
		kD = 10;
	}
	float error = 0;
	float lastError = 0;
	float derivative = 0;
	float correction = 0;
	float time = 0;
	while(distance >= getMotorEncoder(motor_drive_right)/360*PI*tireDiameter)
	{
		error = (32 - getColorReflected(line_follower_right)) * -1;
		time = time1[timer1];
		clearTimer(timer1);
		derivative = error - lastError;
		correction = error*kP + derivative*kD/time;
		setMotorSpeed(motorB, speed + correction);
		setMotorSpeed(motorC, speed - correction);
		lastError = error;
		waitUntil(time1[timer1] >= 8);
	}
}


//_turn
void turn(float speed1, float speed2, float speed3, float radius, float angle)
{
	float speedBrake = 0;
	int counter = 0;
	float rotataionsB = 0;
	float rotataionsC = 0;
	float error = 0;
	float lastError = 0;
	float Derivative = 0;
	float kP = 0.012;
	float kD = 0.05;
	float Correction = 0;
	float AbsRadius = abs(radius);
	float degrees = abs(2*PI*(AbsRadius+tireDistance/2)/(tireDiameter*PI)*angle);
	float left_rightRatio = (AbsRadius-tireDistance/2)/(AbsRadius+tireDistance/2);
	resetMotorEncoder(motor_drive_left);
	resetMotorEncoder(motor_drive_right);
	if(radius < 0)
	{
		if(speed1 <= speed2)
		{
			while(speed1+1.8*counter < speed2)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsC*left_rightRatio)-abs(rotataionsB);
				Correction = error*kP;
				setMotorSpeed(motor_drive_left, (speed1+1.8*counter)*left_rightRatio*(1+Correction));
				setMotorSpeed(motor_drive_right, (speed1+1.8*counter)*(1-Correction));
				wait1Msec(5);
				counter ++;
			}
			} else {
			while(speed1-1.8*counter > speed2)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsC*left_rightRatio)-abs(rotataionsB);
				Correction = error*kP;
				setMotorSpeed(motor_drive_left, (speed1-1.8*counter)*left_rightRatio*(1+Correction));
				setMotorSpeed(motor_drive_right, (speed1-1.8*counter)*(1-Correction));
				wait1Msec(5);
				counter ++;
			}
		}
		if(speed3 < speed2)
		{
			while(degrees-abs(((speed2-speed3)*(speed2+speed3))/2*brakeConsTurn) > abs(getMotorEncoder(motor_drive_right)))
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsC*left_rightRatio)-abs(rotataionsB);
				Derivative = error - lastError;
				Correction = error*kP + Derivative*kD;
				setMotorSpeed(motor_drive_left, speed2*left_rightRatio*(1+Correction));
				setMotorSpeed(motor_drive_right, speed2*(1-Correction));
				lastError = error;
			}
			while(degrees-abs(getMotorEncoder(motor_drive_right)) > 3)
			{
				speedBrake = sqrt(2*(degrees-abs(getMotorEncoder(motor_drive_right)))/brakeConsTurn+pow(speed3,2))*speed2/abs(speed2);
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				setMotorSpeed(motor_drive_left, speedBrake*left_rightRatio);
				setMotorSpeed(motor_drive_right, speedBrake);
			}
			} else {
			while(abs(getMotorEncoder(motor_drive_right)) <= degrees)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsC*left_rightRatio)-abs(rotataionsB);
				Derivative = error - lastError;
				Correction = error*kP + Derivative*kD;
				setMotorSpeed(motor_drive_left, speed2*left_rightRatio*(1+Correction));
				setMotorSpeed(motor_drive_right, speed2*(1-Correction));
				lastError = error;
			}
		}
		} else {
		if(speed1 <= speed2)
		{
			while(speed1+1.8*counter < speed2)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsB*left_rightRatio)-abs(rotataionsC);
				Correction = error*kP;
				setMotorSpeed(motor_drive_left, (speed1+1.8*counter)*(1-Correction));
				setMotorSpeed(motor_drive_right, (speed1+1.8*counter)*left_rightRatio*(1+Correction));
				wait1Msec(5);
				counter ++;
			}
			} else {
			while(speed1-1.8*counter > speed2)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsB*left_rightRatio)-abs(rotataionsC);
				Correction = error*kP;
				setMotorSpeed(motor_drive_left, (speed1-1.8*counter)*(1-Correction));
				setMotorSpeed(motor_drive_right, (speed1-1.8*counter)*left_rightRatio*(1+Correction));
				wait1Msec(5);
				counter ++;
			}
		}
		if(speed3 < speed2)
		{
			while(degrees-abs(((speed2-speed3)*(speed2+speed3))/2*brakeConsTurn) > abs(getMotorEncoder(motor_drive_left)))
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsB*left_rightRatio)-abs(rotataionsC);
				Derivative = error - lastError;
				Correction = error*kP + Derivative*kD;
				setMotorSpeed(motor_drive_left, speed2*(1-Correction));
				setMotorSpeed(motor_drive_right, speed2*left_rightRatio*(1+Correction));
				lastError = error;
			}
			while(degrees-abs(getMotorEncoder(motor_drive_left)) > 3)
			{
				speedBrake = sqrt(2*(degrees-abs(getMotorEncoder(motor_drive_left)))/brakeConsTurn+pow(speed3,2))*speed2/abs(speed2);
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				setMotorSpeed(motor_drive_left, speedBrake);
				setMotorSpeed(motor_drive_right, speedBrake*left_rightRatio);
			}
			} else {
			while(abs(getMotorEncoder(motor_drive_left)) <= degrees)
			{
				rotataionsB = getMotorEncoder(motor_drive_left)*(-1);
				rotataionsC = getMotorEncoder(motor_drive_right);
				error = abs(rotataionsB*left_rightRatio)-abs(rotataionsC);
				Derivative = error - lastError;
				Correction = error*kP + Derivative*kD;
				setMotorSpeed(motor_drive_left, speed2*(1-Correction));
				setMotorSpeed(motor_drive_right, speed2*left_rightRatio*(1+Correction));
				lastError = error;
			}
		}
	}
	if(speed3 == 0)
	{
		setMotorSpeed(motor_drive_left, 0);
		setMotorSpeed(motor_drive_right, 0);
	}
}


//_brake
void brake(float speed, float distance)
{
	float degrees = distance/(tireDiameter*PI)*360;
	float speedBrake = speed;
	setMotorSync(motor_drive_left, motor_drive_right, -100, speed);
	waitUntil(abs(degrees)-abs((speed*(speed+1))/2*brakeCons) <= abs(getMotorEncoder(motor_drive_right)));
	while(abs(degrees)-abs(getMotorEncoder(motor_drive_right)) > 2)
	{
		speedBrake = (-1+sqrt(1+8*(degrees-abs(getMotorEncoder(motor_drive_right)))/brakeCons))/2*speed/abs(speed);
		setMotorSync(motor_drive_left, motor_drive_right, -100, speedBrake);
	}
	setMotorSpeed(motor_drive_left, 0);
	setMotorSpeed(motor_drive_right, 0);
	wait1Msec(10);
}


//_speedChange
void speedChange(float startSpeed, float endSpeed)
{
	int counter = 0;
	if(startSpeed <= endSpeed)
	{
		while(startSpeed+1.8*counter < endSpeed)
		{
			setMotorSync(motor_drive_left, motor_drive_right, -100, startSpeed+1.8*counter);
			wait1Msec(5);
			counter ++;
		}
		} else {
		while(startSpeed-1.8*counter > endSpeed)
		{
			setMotorSync(motor_drive_left, motor_drive_right, -100, startSpeed-1.8*counter);
			wait1Msec(5);
			counter ++;
		}
	}
	setMotorSync(motor_drive_left, motor_drive_right, -100, endSpeed);
}


//_driveCm
void driveCm(float leftSpeed, float rightSpeed, float distance)
{
	if(leftSpeed == rightSpeed)
	{
		setMotorSync(motor_drive_left, motor_drive_right, -100, leftSpeed);
	}
	setMotorSpeed(motor_drive_left, leftSpeed);
	setMotorSpeed(motor_drive_right, rightSpeed);
	waitUntil(abs(distance)/(tireDiameter*PI)*360 <= abs(getMotorEncoder(motor_drive_right)));
}


//_compareRGB
bool compareRGB(int redLow, int redHigh, int greenLow, int greenHigh, int blueLow, int blueHigh, int red, int green, int blue)
{
	bool correct = false;
	if(red > redLow && red < redHigh)
	{
		if(green > greenLow && green < greenHigh)
		{
			if(blue > blueLow && blue < blueHigh)
			{
				correct = true;
			}
		}
	}
	return correct;
}


//_measureBlocks
task measureBlocks()
{
	//float motorRotation = getMotorEncoder(motor_drive_right);
	int redCurrent = 0;
	int blueCurrent = 0;
	int greenCurrent = 0;
	int redMax = 0;
	int	greenMax = 0;
	int	blueMax = 0;

	redMax = 0;
	greenMax = 0;
	blueMax = 0;

	while(true)
	{
		getColorRawRGB(color_right, redCurrent, greenCurrent, blueCurrent);
		if(redCurrent > redMax)
		{
			redMax = redCurrent;
		}
		if(greenCurrent > greenMax)
		{
			greenMax = greenCurrent;
		}
		if(blueCurrent > blueMax)
		{
			blueMax = blueCurrent;
		}

		//datalogDataGroupStart();
		//datalogAddValue(0, redMax + greenMax + blueMax);
		//datalogDataGroupEnd();


		displayTextLine(0, "%d %d %d", redMax, greenMax, blueMax);
		colors[side + 1] = redMax + greenMax + blueMax >  borderRGB;

	}
}
//_measureBlocks_l
task measureBlocks_l()
{
	//float motorRotation = getMotorEncoder(motor_drive_right);
	int redCurrent = 0;
	int blueCurrent = 0;
	int greenCurrent = 0;
	int redMax = 0;
	int	greenMax = 0;
	int	blueMax = 0;

	redMax = 0;
	greenMax = 0;
	blueMax = 0;

	while(true)
	{
		getColorRawRGB(color_left, redCurrent, greenCurrent, blueCurrent);
		if(redCurrent > redMax)
		{
			redMax = redCurrent;
		}
		if(greenCurrent > greenMax)
		{
			greenMax = greenCurrent;
		}
		if(blueCurrent > blueMax)
		{
			blueMax = blueCurrent;
		}

		displayTextLine(1, "%d %d %d", redMax, greenMax, blueMax);
		colors[side + 1] = redMax + greenMax + blueMax >  borderRGB;

	}


}
// _reset_start
task reset_start()
{
	setMotorSpeed(motor_dropper, -5);
	setMotorSpeed(motor_grab, -25);
	wait1Msec(2000);
	setMotorSpeed(motor_dropper, 0);
	setMotorSpeed(motor_grab, 0);
	wait1Msec(200);
	resetMotorEncoder(motor_grab);
	resetMotorEncoder(motor_dropper);
	playTone(440, 100);
	reset = true;
}



// _pickupBottles
void pickupBottles() {
	turn(0, 40, 0, tireDistance/2, 125);
	setMotorTarget(motor_dropper, 140, 50);
	setMotorTarget(motor_grab, 435, 30);
	turn(0, 40, 0, -tireDistance/2, 172);

	setMotorTarget(motor_grab, 70, 20);
	waitUntilMotorStop(motor_grab);
	wait1Msec(200);
	setMotorTarget(motor_grab, 435, 30);
	waitUntilMotorStop(motor_grab);
	delay(200);

	resetMotorEncoder(motor_drive_right);
	driveCm(29, 30, 9.5);
	brake(30, 9.5);

	setMotorTarget(motor_grab, 70, 15);
	waitUntilMotorStop(motor_grab);
}
// _solve_side
void solve_side() {}

// _main
task main()
{
	setMotorBrakeMode(motorA, motorBrake);
	setMotorBrakeMode(motorB, motorBrake);
	setMotorBrakeMode(motorC, motorBrake);
	setMotorBrakeMode(motorD, motorBrake);
	getColorAmbient(color_left);
	getColorAmbient(color_right);
	startTask(reset_start);
	eraseDisplay();
	waitUntil(reset);
	setLEDColor(ledGreen);
	waitForButtonPress();
	eraseDisplay();
	setLEDColor(ledOff);
	delay(150);

	//pickupBottles();


	//// picked up

	//turn(0, 40, 0, -1, 70);
	//turn(0, 60, 60, 47.25, 70);

	setMotorTarget(motor_grab, 435, 20);
	waitUntilMotorStop(motor_grab);
	delay(200);

	resetMotorEncoder(motor_drive_right);
	lfPDcm(15, 10);
	startTask(measureBlocks);
	startTask(measureBlocks_l);
	lfPDline(15, true, true);
	resetMotorEncoder(motor_drive_right);
	lfPDcm(15, 5);
	setMotorTarget(motor_grab, 435, 30);
	stopTask(measureBlocks);
	stopTask(measureBlocks_l);

	turn(15, 40, 0, 21, 88.5);

	// mock drop
	//setMotorTarget(motor_dropper, 0, 20);
	//waitUntilMotorStop(motor_dropper);
	//delay(200);
	//setMotorTarget(motor_dropper, 120, 20);
	//waitUntilMotorStop(motor_dropper);
	//delay(200);

	resetMotorEncoder(motor_drive_right);
	driveCm(60, 60, 23.5);
	brake(60, 28.5);
	delay(500);
	resetMotorEncoder(motor_drive_right);
	driveCm(-60, -60, 90);
	brake(-60, 99);

	for(int i = 0; i < 4; i++)
	{
		displayTextLine(i, "%d", colors[i]);
	}
	delay(10000);



	// 15 6 2
	// 0 4 1
}
